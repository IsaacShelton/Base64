
// Ported and built upon by Isaac Shelton from Jouni Malinen's https://web.mit.edu/freebsd/head/contrib/wpa/src/utils/base64.c

/*
 * Base64 encoding/decoding (RFC1341)
 * Copyright (c) 2005-2011, Jouni Malinen <j@w1.fi>
 *
 * This software may be distributed under the terms of the BSD license.
 * See README for more details.
 */

pragma compiler_supports '2.5'

import String
import cstdlib
import cstring

base64\table String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

func base64\encode(input String) String {
    base64\encode(input, def output String)
    return output.commit()
}

func base64\decode(input String) String {
    base64\decode(input, def output String)
    return output.commit()
}

func base64\encode(input String, output *String, do_newlines bool = false) successful {
    array *ubyte = base64\encode(input.array, input.length, undef length usize, do_newlines)
    
    if array {
        output.__defer__()
        output.array = array
        output.length = length
        output.capacity = length
        output.ownership = StringOwnership::OWN
    } else {
        output.clear()
    }

    return array != null
}

func base64\decode(input String, output *String) successful {
    array *ubyte = base64\decode(input.array, input.length, undef length usize)
    
    if array {
        output.__defer__()
        output.array = array
        output.length = length
        output.capacity = length
        output.ownership = StringOwnership::OWN
    } else {
        output.clear()
    }

    return array != null
}

/**
 * base64_encode - Base64 encode
 * @src: Data to be encoded
 * @len: Length of the data to be encoded
 * @out_len: Pointer to output length variable, or %NULL if not used
 * Returns: Allocated buffer of out_len bytes of encoded data,
 * or %NULL on failure
 *
 * Caller is responsible for freeing the returned buffer. Returned buffer is
 * nul terminated to make it easier to use as a C string. The nul terminator is
 * not included in out_len.
 */
func base64\encode(src *ubyte, len usize, out_len *usize, do_newlines bool = false) *ubyte {
    output, pos *ubyte = undef
    end, input *ubyte = undef
    olen usize = undef
    line_len int = undef

    olen = len * 4 / 3 + 4 // 3-byte blocks to 4-byte
    olen += olen / 72      // line feeds
    olen++                 // NUL termination

    if olen < len, return null // integer overflow

    output = malloc(olen)
    unless output, return null

    end = src at len
    input = src
    pos = output
    line_len = 0

    while end - input >= cast ptr 3 {
        *pos = base64\table[input[0] >> 2]
        pos = pos at 1
        *pos = base64\table[((input[0] & 0x03) << 4) | (input[1] >> 4)]
        pos = pos at 1
        *pos = base64\table[((input[1] & 0x0f) << 2) | (input[2] >> 6)]
        pos = pos at 1
        *pos = base64\table[input[2] & 0x3f]
        pos = pos at 1

        input = input at 3
        line_len += 4

        if do_newlines && line_len >= 72 {
            *pos = '\n'ub
            pos = pos at 1
            line_len = 0
        }
    }

    if end - input {
        *pos = base64\table[input[0] >> 2]
        pos = pos at 1

        if end - input == cast ptr 1 {
            *pos = base64\table[(input[0] & 0x03) << 4]
            pos = pos at 1
            *pos = '='ub
            pos = pos at 1
        } else {
            *pos = base64\table[((input[0] & 0x03) << 4) | (input[1] >> 4)]
            pos = pos at 1
            *pos = base64\table[(input[1] & 0x0f) << 2]
            pos = pos at 1
        }
        *pos = '='ub
        pos = pos at 1
        line_len += 4
    }

    if do_newlines && line_len {
        *pos = '\n'ub
        pos = pos at 1
    }

    *pos = 0x00ub
    if out_len, *out_len = cast usize (pos - output)
    return output
}


/**
 * base64_decode - Base64 decode
 * @src: Data to be decoded
 * @len: Length of the data to be decoded
 * @out_len: Pointer to output length variable
 * Returns: Allocated buffer of out_len bytes of decoded data,
 * or %NULL on failure
 *
 * Caller is responsible for freeing the returned buffer.
 */
func base64\decode(src *ubyte, len usize, out_len *usize) *ubyte {
    dtable 256 ubyte = undef
    output, pos *ubyte = undef
    block 4 ubyte = undef
    tmp ubyte = undef
    i, count, olen usize = undef
    pad int = 0

    memset(cast *ubyte &dtable, 0x80, 256)

    for(i = 0; i < base64\table.length - 1; i++), dtable[base64\table[i]] = i as ubyte
    dtable['='ub] = 0

    count = 0
    for(i = 0; i < len; i++){
        if dtable[src[i]] != 0x80ub, count++
    }

    if count == 0 || count % 4, return null

    olen = count / 4 * 3
    output = malloc(olen)
    pos = output

    unless output, return null

    count = 0
    for(i = 0; i < len; i++){
        tmp = dtable[src[i]]

        if tmp == 0x80, continue
        if src[i] == '='ub, pad++

        block[count] = tmp
        count++

        if count == 4 {
            *pos = (block[0] << 2) | (block[1] >> 4)
            pos = pos at 1
            *pos = (block[1] << 4) | (block[2] >> 2)
            pos = pos at 1
            *pos = (block[2] << 6) | block[3]
            pos = pos at 1

            count = 0

            if pad {
                if   pad == 1, pos = cast ptr (cast usize pos - 1) // pos at -1
                elif pad == 2, pos = cast ptr (cast usize pos - 1) // pos at -2
                else {
                    // Invalid padding
                    free(output)
                    return null
                }
                break
            }
        }
    }

    *out_len = cast usize (pos - output)
    return output
}
